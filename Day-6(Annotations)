üîç Understanding the Differences between Service, Component, and Controller Annotations! üîç
1Ô∏è‚É£ @Service: This annotation is typically used to mark a class as a service component in the business logic layer. Services handle business operations and encapsulate complex logic. They often interact with data access objects (DAOs) and expose functionality to other components in the application. With the @Service annotation, we can leverage dependency injection, transaction management, and other features provided by the framework.
2Ô∏è‚É£ @Component: The @Component annotation is the most generic annotation used to mark a class as a Spring-managed component. It serves as a generic stereotype for any Spring-managed component. Components can be considered as building blocks that can be wired together to create larger systems. They provide functionality that can be shared across different layers of the application.
3Ô∏è‚É£ @Controller: The @Controller annotation is specific to the Spring MVC framework and is used to mark a class as a controller component. Controllers handle incoming requests, interact with the model (data), and produce a response. They act as a bridge between the user interface and the business logic layer. Controllers often work in conjunction with the @RequestMapping annotation to map incoming requests to specific methods.
üîç Annotations used in project and their levelsüîç
@SpringBootApplication: It enables auto-configuration, component scanning and marks the class as a configuration class.
Level: Class level (for the main class)
@Autowired: used to inject dependencies automatically. It can be applied to fields, constructors, or setter methods of a class.
Level: method level.
@Service: It is typically used to define services that encapsulate
 business logic and can be autodetected by Spring's component scanning mechanism. Level: Class level.
@Repository: used to mark a class as a repository component, typically used for database access or persistence. 
Level: Class level.
@RestController: It is used to handle HTTP requests and automatically converts the response to JSON or XML (based on configuration) 
Level: Class level.
@GetMapping: used to map HTTP GET requests to a specific method in a controller. 
Level: Method level.
@PostMapping: used to map HTTP POST requests to a specific method in a controller. 
Level: Method level.
@Entity: used to mark a class as a JPA (Java Persistence API) entity. 
Level: Class level.
@GeneratedValue: It defines how the primary key value is automatically generated by the underlying database.
Level: Field level.
